/* eslint-disable no-param-reassign */
/* eslint-disable no-underscore-dangle */
/* eslint-disable react/jsx-props-no-spreading */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useMemo, useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { cloneDeep } from "lodash";
import { Color } from "three";
import PropTypes from "prop-types";
import { useFrame, useThree } from "@react-three/fiber";
import { TWEEN } from "three/examples/jsm/libs/tween.module.min";

const House = ({ wireframe }) => {
  const group = useRef();
  const model = useGLTF(
    "/models/shaji_7.glb",
    "https://www.gstatic.com/draco/versioned/decoders/1.4.0/"
    // "https://www.gstatic.com/draco/versioned/decoders/1.3.6/"
    // "https://www.gstatic.com/draco/v1/decoders/draco_wasm_wrapper.js"
    // the default draco-loader is not working, so using a versioned one
    // check if the default one is working by removing the above line (later)
  );
  const { nodes } = model;
  let { materials } = model;

  if (wireframe) {
    materials = useMemo(() => cloneDeep(materials), [materials]);

    Object.values(materials).forEach((value) => {
      value.wireframe = true;
      value.color = new Color("#fff");
      value.transparent = true;
      value.opacity = 0.1;
    });
  }

  const houseRef = useRef();

  useFrame(() => {
    TWEEN.update();
  });

  const { camera } = useThree();

  useEffect(() => {
    new TWEEN.Tween(camera.position)
      .to(
        {
          x: 100,
          y: 0,
          z: 80,
        },
        1000
      )
      .start();

    const introSection = document.querySelector(".basic-info-container");

    const observerOnUp = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            new TWEEN.Tween(camera.position)
              .to(
                {
                  x: 100,
                  y: 0,
                  z: 80,
                },
                1000
              )
              .start();

            new TWEEN.Tween(houseRef.current.position)
              .to(
                {
                  x: 0,
                  y: 0,
                  z: 0,
                },
                1000
              )
              .start();

            new TWEEN.Tween(houseRef.current.rotation)
              .to(
                {
                  x: 0,
                  y: 0,
                  z: 0,
                },
                1000
              )
              .start();
          }
        });
      },
      {
        threshold: 1,
      }
    );
    console.log(window.innerWidth);

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (!entry.isIntersecting) {
            new TWEEN.Tween(camera.position)
              .to(
                {
                  x: 0,
                  y: 10,
                  z: 300,
                },
                1000
              )
              .start();

            new TWEEN.Tween(houseRef.current.position)
              .to(
                {
                  x: -300,
                  y: 10,
                  z: 0,
                },
                1000
              )
              .start();

            new TWEEN.Tween(houseRef.current.rotation)
              .to(
                {
                  x: 0,
                  y: Math.PI + 0.5,
                  z: 0,
                },
                1000
              )
              .start();

            observerOnUp.observe(introSection);
          }
        });
      },
      {
        threshold: 1,
      }
    );

    observer.observe(introSection);

    const aboutCardsSection = document.querySelector(".about-cards");
    const aboutWorkContainer = document.querySelector(
      ".about-the-work-container"
    );

    let scrolledValue = 0;
    const zoomHouse = () => {
      if (scrolledValue === 0) scrolledValue = aboutWorkContainer.scrollTop;
      camera.position.setZ(
        Math.max(80, 300 - (aboutWorkContainer.scrollTop - scrolledValue))
      );
      houseRef.current.position.setX(
        Math.min(0, -300 + (aboutWorkContainer.scrollTop - scrolledValue))
      );
      houseRef.current.rotation.y =
        Math.PI + 0.5 + (aboutWorkContainer.scrollTop - scrolledValue) / 1000;
    };

    const aboutWorkObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            aboutWorkContainer.addEventListener("scroll", zoomHouse);
            entry.target.classList.add("appear");
          } else {
            aboutWorkContainer.removeEventListener("scroll", zoomHouse);
          }
        });
      },
      {
        threshold: 0,
      }
    );

    aboutWorkObserver.observe(aboutCardsSection);

    return () => {
      observer.unobserve(introSection);
      observerOnUp.unobserve(introSection);
      aboutWorkObserver.unobserve(introSection);
    };
  }, []);

  return (
    <group ref={houseRef} dispose={null}>
      <group rotation={[0, 0, 0]} scale={0.5}>
        <group position={[0, 0, 0]} scale={[0.1, 0.1, 0.1]}>
          <mesh
            geometry={nodes.Mesh150.geometry}
            material={materials.Color_000}
          />
          <mesh
            geometry={nodes.Mesh150_1.geometry}
            material={materials.Color_F08}
          />
          <mesh
            geometry={nodes.Mesh150_2.geometry}
            material={materials.Color_B24}
          />
          <mesh
            geometry={nodes.Mesh150_3.geometry}
            material={materials._Color_A02_2}
          />
          <mesh
            geometry={nodes.Mesh150_4.geometry}
            material={materials.Color_F24}
          />
          <mesh
            geometry={nodes.Mesh150_5.geometry}
            material={materials.Color_A06}
          />
          <mesh
            geometry={nodes.Mesh150_6.geometry}
            material={materials.Translucent_Glass_Tinted}
          />
          <mesh
            geometry={nodes.Mesh150_7.geometry}
            material={materials._Metal_Rusted_1}
          />
          <mesh
            geometry={nodes.Mesh150_8.geometry}
            material={materials.Color_A02}
          />
          <mesh
            geometry={nodes.Mesh150_9.geometry}
            material={materials._Color_A02_1}
          />
          <mesh
            geometry={nodes.Mesh150_10.geometry}
            material={materials.Roofing_Shingles_Multi}
          />
          <mesh
            geometry={nodes.Mesh150_11.geometry}
            material={materials.Roofing_Slate_Dark}
          />
          <mesh
            geometry={nodes.Mesh150_12.geometry}
            material={materials.Translucent_Glass_Gray}
          />
          <mesh
            geometry={nodes.Mesh150_13.geometry}
            material={materials.Color_008}
          />
          <mesh
            geometry={nodes.Mesh150_14.geometry}
            material={materials.Color_A18}
          />
          <points
            geometry={nodes.Mesh150_15.geometry}
            material={materials.Color_000}
          />
        </group>
      </group>
    </group>
  );
};

useGLTF.preload("/models/shaji_7-transformed.glb");

House.propTypes = {
  wireframe: PropTypes.bool,
};

House.defaultProps = {
  wireframe: false,
};

export default House;
